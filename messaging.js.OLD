/**
 * messaging.js
 * Beheert alle messaging functionaliteit tussen programmeurs en artiesten
 */

import { collection, addDoc, doc, setDoc, getDoc, serverTimestamp, query, where, getDocs, orderBy, onSnapshot } from "firebase/firestore";
import { db } from './firebase.js';
import { getStore } from './store.js';

// Globale variabele om de huidige artiest bij te houden
let currentArtistForMessage = null;

/**
 * Opent de message modal voor een specifieke artiest
 * @param {object} artist - Het artiest object
 */
export function openMessageModal(artist) {
  const modal = document.getElementById('message-modal');
  const artistNameSpan = document.getElementById('message-artist-name');
  const messageError = document.getElementById('message-error');
  const messageSuccess = document.getElementById('message-success');
  
  // Sla de artiest op voor later gebruik
  currentArtistForMessage = artist;
  
  // Update de modal
  artistNameSpan.textContent = artist.stageName || `${artist.firstName} ${artist.lastName}`;
  
  // Reset form en messages
  document.getElementById('send-message-form').reset();
  messageError.style.display = 'none';
  messageSuccess.style.display = 'none';
  
  // Toon modal
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  
  // Activeer Lucide icons
  if (window.lucide) {
    window.lucide.createIcons();
  }
}

/**
 * Sluit de message modal
 */
function closeMessageModal() {
  const modal = document.getElementById('message-modal');
  modal.classList.add('hidden');
  modal.classList.remove('flex');
  currentArtistForMessage = null;
}

/**
 * Verwerkt het versturen van een bericht
 */
async function handleSendMessage(e) {
  e.preventDefault();
  
  const messageError = document.getElementById('message-error');
  const messageSuccess = document.getElementById('message-success');
  const submitBtn = e.submitter || e.target.querySelector('button[type="submit"]');
  
  // Reset messages
  messageError.style.display = 'none';
  messageSuccess.style.display = 'none';
  
  // Disable button
  submitBtn.disabled = true;
  submitBtn.innerHTML = '<i data-lucide="loader" class="h-4 w-4 mr-2 animate-spin"></i>Sending...';
  
  try {
    // Haal gegevens op
    const currentUser = getStore('currentUser');
    const currentUserData = getStore('currentUserData');
    
    if (!currentUser || !currentUserData) {
      throw new Error('User not logged in');
    }
    
    if (!currentArtistForMessage) {
      throw new Error('No artist selected');
    }
    
    const subject = document.getElementById('message-subject').value.trim();
    const messageText = document.getElementById('message-text').value.trim();
    
    if (!subject || !messageText) {
      throw new Error('Please fill in all fields');
    }
    
    // Check of er al een conversatie bestaat tussen deze twee users
    const existingConversation = await findExistingConversation(
      currentUser.uid, 
      currentArtistForMessage.uid || currentArtistForMessage.id
    );
    
    let conversationId;
    
    if (existingConversation) {
      // Gebruik bestaande conversatie
      conversationId = existingConversation.id;
      console.log("Using existing conversation:", conversationId);
    } else {
      // Maak nieuwe conversatie aan
      conversationId = await createConversation(
        currentUser.uid,
        currentUserData,
        currentArtistForMessage,
        subject
      );
      console.log("Created new conversation:", conversationId);
    }
    
    // Voeg bericht toe aan conversatie
    await addMessage(conversationId, currentUser.uid, currentUserData, messageText);
    
    // Toon success bericht
    messageSuccess.textContent = 'Message sent successfully!';
    messageSuccess.style.display = 'block';
    
    // Sluit modal na 2 seconden
    setTimeout(() => {
      closeMessageModal();
    }, 2000);
    
  } catch (error) {
    console.error("Error sending message:", error);
    messageError.textContent = error.message || 'Failed to send message. Please try again.';
    messageError.style.display = 'block';
    
    // Re-enable button
    submitBtn.disabled = false;
    submitBtn.innerHTML = '<i data-lucide="send" class="h-4 w-4 mr-2"></i>Send Message';
    if (window.lucide) {
      window.lucide.createIcons();
    }
  }
}

/**
 * Zoekt naar een bestaande conversatie tussen twee users
 */
async function findExistingConversation(userId1, userId2) {
  try {
    const conversationsRef = collection(db, 'conversations');
    
    // Query voor conversaties waar beide users participants zijn
    const q = query(
      conversationsRef,
      where('participants', 'array-contains', userId1)
    );
    
    const querySnapshot = await getDocs(q);
    
    // Filter client-side voor de tweede participant
    let existingConv = null;
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      if (data.participants.includes(userId2)) {
        existingConv = { id: doc.id, ...data };
      }
    });
    
    return existingConv;
  } catch (error) {
    console.error("Error finding existing conversation:", error);
    return null;
  }
}

/**
 * Maakt een nieuwe conversatie aan
 */
async function createConversation(programmerId, programmerData, artist, subject) {
  const artistId = artist.uid || artist.id;
  
  const conversationData = {
    participants: [programmerId, artistId],
    participantNames: {
      [programmerId]: `${programmerData.firstName} ${programmerData.lastName}`,
      [artistId]: artist.stageName || `${artist.firstName} ${artist.lastName}`
    },
    participantRoles: {
      [programmerId]: 'programmer',
      [artistId]: 'artist'
    },
    participantEmails: {
      [programmerId]: programmerData.email,
      [artistId]: artist.email
    },
    // ‚≠ê NEW: Add profile pictures
    participantProfilePics: {
      [programmerId]: programmerData.profilePicUrl || '',
      [artistId]: artist.profilePicUrl || ''
    },
    subject: subject,
    lastMessage: '',
    lastMessageAt: serverTimestamp(),
    unreadBy: [artistId],
    createdAt: serverTimestamp()
  };
  
  const docRef = await addDoc(collection(db, 'conversations'), conversationData);
  return docRef.id;
}

/**
 * Voegt een bericht toe aan een conversatie
 * ‚úÖ FIX: Exported for use in ui.js
 */
export async function addMessage(conversationId, senderId, senderData, messageText) {
  // 1. Voeg bericht toe aan messages subcollection
  const messageData = {
    senderId: senderId,
    senderName: `${senderData.firstName} ${senderData.lastName}`,
    senderRole: senderData.role,
    senderProfilePic: senderData.profilePicUrl || '', // ‚≠ê NEW: Add profile picture
    text: messageText,
    createdAt: serverTimestamp(),
    read: false
  };
  
  await addDoc(collection(db, `conversations/${conversationId}/messages`), messageData);
  
  // 2. Update de conversatie met laatste bericht info
  const conversationRef = doc(db, 'conversations', conversationId);
  const conversationSnap = await getDoc(conversationRef);
  const conversationData = conversationSnap.data();
  
  // Bepaal wie de ontvanger is (de andere participant)
  const receiverId = conversationData.participants.find(id => id !== senderId);
  
  await setDoc(conversationRef, {
    lastMessage: messageText.substring(0, 100),
    lastMessageAt: serverTimestamp(),
    unreadBy: [receiverId]
  }, { merge: true });
}

/**
 * Laadt alle conversaties voor de ingelogde gebruiker
 */
export async function loadConversations() {
  const currentUser = getStore('currentUser');
  
  if (!currentUser) {
    console.error("No user logged in");
    return;
  }
  
  const loadingEl = document.getElementById('conversations-loading');
  const emptyEl = document.getElementById('conversations-empty');
  const listEl = document.getElementById('conversations-list');
  
  // Toon loading state
  if (loadingEl) loadingEl.style.display = 'block';
  if (emptyEl) emptyEl.style.display = 'none';
  if (listEl) {
    listEl.style.display = 'none';
    listEl.innerHTML = '';
  }
  
  try {
    // Query conversaties waar de user een participant is
    const conversationsRef = collection(db, 'conversations');
    const q = query(
      conversationsRef,
      where('participants', 'array-contains', currentUser.uid),
      orderBy('lastMessageAt', 'desc')
    );
    
    const querySnapshot = await getDocs(q);
    
    const conversations = [];
    querySnapshot.forEach((doc) => {
      conversations.push({ id: doc.id, ...doc.data() });
    });
    
    // Verberg loading
    if (loadingEl) loadingEl.style.display = 'none';
    
    if (conversations.length === 0) {
      // Toon empty state
      if (emptyEl) emptyEl.style.display = 'block';
    } else {
      // Toon conversaties
      displayConversations(conversations);
    }
    
    // Update unread badge
    updateUnreadBadge(conversations, currentUser.uid);
    
  } catch (error) {
    console.error("Error loading conversations:", error);
    if (loadingEl) {
      loadingEl.innerHTML = `
        <div class="text-center py-8">
          <p class="text-red-500">Error loading conversations. Please refresh the page.</p>
          <p class="text-sm text-gray-500 mt-2">${error.message}</p>
        </div>
      `;
    }
  }
}

/**
 * Toont de lijst met conversaties
 */
async function displayConversations(conversations) {
  const listEl = document.getElementById('conversations-list');
  const currentUser = getStore('currentUser');
  
  if (!listEl || !currentUser) return;
  
  listEl.innerHTML = '';
  listEl.style.display = 'block';
  
  // ‚≠ê NEW: Fetch profile pictures for all participants
  const conversationsWithPics = await Promise.all(conversations.map(async (conversation) => {
    // Bepaal de andere participant
    const otherParticipantId = conversation.participants.find(id => id !== currentUser.uid);
    const otherParticipantRole = conversation.participantRoles[otherParticipantId] || '';
    
    // ‚≠ê Fetch profile picture from Firestore
    let profilePic = conversation.participantProfilePics?.[otherParticipantId] || '';
    
    // If not in conversation data, fetch from user's profile
    if (!profilePic) {
      try {
        const collection = otherParticipantRole === 'artist' ? 'artists' : 'programmers';
        const userDocRef = doc(db, collection, otherParticipantId);
        const userDocSnap = await getDoc(userDocRef);
        
        if (userDocSnap.exists()) {
          profilePic = userDocSnap.data().profilePicUrl || '';
        }
      } catch (error) {
        console.error("Error fetching profile picture:", error);
      }
    }
    
    return {
      ...conversation,
      otherParticipantId,
      otherParticipantRole,
      otherParticipantPic: profilePic
    };
  }));
  
  // Now display all conversations with their profile pictures
  conversationsWithPics.forEach(conversation => {
    const otherParticipantName = conversation.participantNames[conversation.otherParticipantId] || 'Unknown';
    
    // ‚≠ê Use fetched profile picture with fallback
    const profilePic = conversation.otherParticipantPic || 
                       'https://placehold.co/80x80/e0e7ff/6366f1?text=' + 
                       encodeURIComponent(otherParticipantName.charAt(0));
    
    // Check of dit bericht unread is
    const isUnread = conversation.unreadBy && conversation.unreadBy.includes(currentUser.uid);
    
    // Format timestamp
    let timeAgo = 'Just now';
    if (conversation.lastMessageAt && conversation.lastMessageAt.toDate) {
      const date = conversation.lastMessageAt.toDate();
      timeAgo = formatTimeAgo(date);
    }
    
    // Maak conversation card
    const conversationCard = document.createElement('div');
    conversationCard.className = `border border-gray-200 rounded-lg p-4 hover:bg-gray-50 cursor-pointer transition ${isUnread ? 'bg-indigo-50 border-indigo-300' : ''}`;
    conversationCard.dataset.conversationId = conversation.id;
    conversationCard.dataset.otherParticipantId = conversation.otherParticipantId;
    conversationCard.dataset.otherParticipantRole = conversation.otherParticipantRole;
    
    // Profile Picture with Hover Effect
    conversationCard.innerHTML = `
      <div class="flex items-start space-x-4">
        <!-- Profile Picture with Hover Effect -->
        <div class="relative group flex-shrink-0">
          <img src="${profilePic}" 
               alt="${otherParticipantName}" 
               class="h-16 w-16 rounded-full object-cover border-2 ${isUnread ? 'border-indigo-300' : 'border-gray-200'} cursor-pointer hover:border-indigo-500 transition-all duration-200 hover:shadow-lg transform hover:scale-105"
               data-view-profile="${conversation.otherParticipantId}"
               data-profile-role="${conversation.otherParticipantRole}">
          
          <!-- Hover Tooltip -->
          <div class="absolute -bottom-2 left-1/2 transform -translate-x-1/2 translate-y-full opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10">
            <div class="bg-gray-900 text-white text-xs px-2 py-1 rounded shadow-lg whitespace-nowrap mt-1">
              <svg class="inline-block h-3 w-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
              </svg>
              View profile
            </div>
          </div>
          
          <!-- Click indicator icon -->
          <div class="absolute bottom-0 right-0 h-5 w-5 bg-indigo-500 rounded-full flex items-center justify-center shadow-md opacity-0 group-hover:opacity-100 transition-opacity duration-200">
            <svg class="h-3 w-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </div>
        </div>
        
        <!-- Conversation Info -->
        <div class="flex-1 min-w-0">
          <div class="flex items-center mb-1">
            <h3 class="text-lg font-semibold ${isUnread ? 'text-indigo-900' : 'text-gray-900'} truncate">${otherParticipantName}</h3>
            ${isUnread ? '<span class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-500 text-white flex-shrink-0">New</span>' : ''}
            <span class="ml-2 text-sm text-gray-500 capitalize flex-shrink-0">${conversation.otherParticipantRole}</span>
          </div>
          <p class="text-sm text-gray-700 mb-1"><strong>Subject:</strong> ${conversation.subject || 'No subject'}</p>
          <p class="text-sm text-gray-600 line-clamp-2">${conversation.lastMessage || 'No messages yet'}</p>
        </div>
        
        <!-- Timestamp & Status -->
        <div class="text-right flex-shrink-0">
          <p class="text-xs text-gray-500 whitespace-nowrap">${timeAgo}</p>
          ${isUnread ? '<div class="mt-2"><i data-lucide="mail" class="h-5 w-5 text-indigo-600"></i></div>' : ''}
        </div>
      </div>
    `;
    
    // Click handler om conversatie te openen OF profiel te bekijken
    conversationCard.addEventListener('click', (e) => {
      // Check if clicked on profile picture
      if (e.target.hasAttribute('data-view-profile')) {
        e.stopPropagation();
        const userId = e.target.getAttribute('data-view-profile');
        const role = e.target.getAttribute('data-profile-role');
        viewUserProfile(userId, role);
      } else {
        openConversation(conversation.id);
      }
    });
    
    listEl.appendChild(conversationCard);
  });
  
  // Activeer Lucide icons
  if (window.lucide) {
    window.lucide.createIcons();
  }
}

/**
 * ‚ú® ENHANCED: Update all unread badges in navigation (desktop, mobile, legacy)
 */
function updateUnreadBadge(conversations, currentUserId) {
  // Get all badge elements
  const badgeDesktop = document.getElementById('messages-badge-desktop');
  const badgeMobile = document.getElementById('messages-badge-mobile');
  const badgeLegacy = document.getElementById('messages-badge'); // Legacy badge

  // Tel unread conversaties
  const unreadCount = conversations.filter(conv =>
    conv.unreadBy && conv.unreadBy.includes(currentUserId)
  ).length;

  console.log(`[MESSAGING] Updating badges: ${unreadCount} unread conversations`);

  // Update desktop badge
  if (badgeDesktop) {
    if (unreadCount > 0) {
      badgeDesktop.textContent = unreadCount;
      badgeDesktop.classList.remove('hidden');
    } else {
      badgeDesktop.classList.add('hidden');
    }
  }

  // Update mobile badge
  if (badgeMobile) {
    if (unreadCount > 0) {
      badgeMobile.textContent = unreadCount;
      badgeMobile.classList.remove('hidden');
    } else {
      badgeMobile.classList.add('hidden');
    }
  }

  // Update legacy badge (if it exists)
  if (badgeLegacy) {
    if (unreadCount > 0) {
      badgeLegacy.textContent = unreadCount;
      badgeLegacy.classList.remove('hidden');
    } else {
      badgeLegacy.classList.add('hidden');
    }
  }
}

/**
 * Format timestamp naar "time ago" formaat
 */
function formatTimeAgo(date) {
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  
  // Format as date if older than a week
  return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
}

// ========== FASE 3: CONVERSATION DETAIL VIEW ==========

/**
 * Opent de conversation detail view voor een specifieke conversatie
 */
export async function openConversation(conversationId) {
  console.log("Opening conversation:", conversationId);

  try {
    const currentUser = getStore('currentUser');

    if (!currentUser) {
      console.error("No user logged in");
      return;
    }

    // Haal conversatie data op
    const conversationRef = doc(db, 'conversations', conversationId);
    const conversationSnap = await getDoc(conversationRef);

    if (!conversationSnap.exists()) {
      console.error("Conversation not found:", conversationId);
      alert("Conversation not found.");
      return;
    }

    const conversation = { id: conversationSnap.id, ...conversationSnap.data() };

    // Bepaal de andere participant
    const otherParticipantId = conversation.participants.find(id => id !== currentUser.uid);
    const otherParticipantName = conversation.participantNames[otherParticipantId] || 'Unknown';
    const otherParticipantRole = conversation.participantRoles[otherParticipantId] || '';

    // Show chat container and hide placeholder
    const chatPlaceholder = document.getElementById('chat-placeholder');
    const chatContainer = document.getElementById('chat-container');
    const chatHeader = document.getElementById('chat-header');

    // ‚≠ê MOBILE FIX: Get the chat area wrapper (parent of chatContainer)
    const chatAreaWrapper = chatContainer?.parentElement;

    // ‚≠ê BUG FIX 2: Hide conversation list on mobile when opening chat
    const conversationsList = document.querySelector('.md\\:w-1\\/3');
    if (conversationsList) {
      conversationsList.classList.add('hidden', 'md:block');
    }

    // ‚≠ê MOBILE FIX: Make chat area wrapper visible on mobile
    if (chatAreaWrapper) {
      // Remove 'hidden' class and add mobile visibility
      chatAreaWrapper.classList.remove('hidden');
      chatAreaWrapper.classList.add('flex', 'w-full', 'md:w-2/3');
      chatAreaWrapper.style.display = 'flex';
    }

    if (chatPlaceholder) chatPlaceholder.style.display = 'none';
    if (chatContainer) {
      chatContainer.classList.remove('hidden');
      chatContainer.classList.add('flex');
      chatContainer.style.display = 'flex';
      // ‚≠ê NEW: Store conversation ID for message form
      chatContainer.dataset.conversationId = conversationId;
    }

    // Update chat header with participant info (add back button for mobile)
    if (chatHeader) {
      chatHeader.innerHTML = `
        <div class="flex items-center">
          <button id="back-to-conversations-mobile" class="mr-3 md:hidden text-gray-600 hover:text-gray-900">
            <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          <div>
            <h3 class="text-lg font-semibold text-gray-900">${otherParticipantName}</h3>
            <p class="text-sm text-gray-500">${otherParticipantRole}</p>
            ${conversation.subject ? `<p class="text-sm text-gray-600 mt-1"><strong>Subject:</strong> ${conversation.subject}</p>` : ''}
          </div>
        </div>
      `;

      // ‚≠ê BUG FIX 2: Add event listener for mobile back button
      const backBtn = document.getElementById('back-to-conversations-mobile');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          // ‚≠ê MOBILE FIX: Hide chat area wrapper on mobile
          if (chatAreaWrapper) {
            chatAreaWrapper.classList.add('hidden', 'md:flex');
            chatAreaWrapper.classList.remove('flex', 'w-full');
            chatAreaWrapper.style.display = '';
          }
          // Hide chat container
          if (chatContainer) {
            chatContainer.classList.add('hidden');
            chatContainer.style.display = 'none';
          }
          // Show conversation list
          if (conversationsList) {
            conversationsList.classList.remove('hidden', 'md:block');
            conversationsList.classList.add('block');
          }
          // Show placeholder on desktop
          if (chatPlaceholder) {
            chatPlaceholder.style.display = '';
          }
        });
      }
    }

    // Markeer conversatie als gelezen
    await markConversationAsRead(conversationId);

    // Laad berichten
    await loadMessages(conversationId);

    // Activeer Lucide icons
    if (window.lucide) {
      window.lucide.createIcons();
    }

  } catch (error) {
    console.error("Error opening conversation:", error);
    alert("Could not open conversation: " + error.message);
  }
}

/**
 * Laadt alle berichten van een conversatie
 * ‚úÖ FIX: Exported for use in ui.js
 */
export async function loadMessages(conversationId) {
  const messagesContainer = document.getElementById('messages-container');

  if (!messagesContainer) {
    console.error("Messages container not found");
    return;
  }

  // Show loading state
  messagesContainer.innerHTML = '<p class="text-center text-gray-500">Loading messages...</p>';

  try {
    const messagesRef = collection(db, `conversations/${conversationId}/messages`);
    const q = query(messagesRef, orderBy('createdAt', 'asc'));

    const querySnapshot = await getDocs(q);

    const messages = [];
    querySnapshot.forEach((doc) => {
      messages.push({ id: doc.id, ...doc.data() });
    });

    // Display messages
    displayMessages(messages, conversationId);

  } catch (error) {
    console.error("Error loading messages:", error);
    messagesContainer.innerHTML = `
      <div class="text-center py-8">
        <p class="text-red-500">Error loading messages. Please refresh the page.</p>
        <p class="text-sm text-gray-500 mt-2">${error.message}</p>
      </div>
    `;
  }
}

/**
 * Toont de lijst met berichten
 */
// ‚≠ê REPLACE the displayMessages function in messaging.js (around line 516)
// This version shows actual profile pictures with a hover tooltip

function displayMessages(messages, conversationId) {
  const messagesContainer = document.getElementById('messages-container');
  const currentUser = getStore('currentUser');

  if (!messagesContainer || !currentUser) return;

  messagesContainer.innerHTML = '';

  if (messages.length === 0) {
    messagesContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No messages yet.</p>';
  } else {
    messages.forEach(message => {
      const isOwnMessage = message.senderId === currentUser.uid;

      // Format timestamp
      let timeAgo = 'Just now';
      if (message.createdAt && message.createdAt.toDate) {
        const date = message.createdAt.toDate();
        timeAgo = formatTimeAgo(date);
      }

      // Get profile picture with proper fallback
      const profilePic = message.senderProfilePic ||
                        'https://placehold.co/48x48/e0e7ff/6366f1?text=' +
                        encodeURIComponent(message.senderName?.charAt(0) || '?');

      // Create message bubble
      const messageDiv = document.createElement('div');
      messageDiv.className = `flex items-start space-x-3 mb-4 ${isOwnMessage ? 'flex-row-reverse space-x-reverse' : ''}`;

      messageDiv.innerHTML = `
        <div class="flex-shrink-0">
          <img src="${profilePic}"
               alt="${message.senderName}"
               class="h-10 w-10 rounded-full object-cover">
        </div>

        <div class="max-w-xl ${isOwnMessage ? 'bg-indigo-100' : 'bg-gray-100'} rounded-lg p-4 shadow-sm">
          <div class="flex items-center mb-2">
            <span class="font-semibold text-sm ${isOwnMessage ? 'text-indigo-900' : 'text-gray-900'}">${message.senderName}</span>
            <span class="text-xs text-gray-500 ml-2 capitalize">${message.senderRole || ''}</span>
          </div>
          <p class="text-gray-800 whitespace-pre-wrap">${message.text}</p>
          <p class="text-xs text-gray-500 mt-2">${timeAgo}</p>
        </div>
      `;

      messagesContainer.appendChild(messageDiv);
    });
  }

  // ‚≠ê IMPROVED: Scroll to latest message with smooth behavior
setTimeout(() => {
  messagesContainer.scrollTo({
    top: messagesContainer.scrollHeight,
    behavior: 'smooth'
  });
}, 100);
}

/**
 * ‚ú® OPTIMISTIC UI: Append a single message to the UI immediately
 * @param {object} message - Message data to append
 */
export function appendMessageToUI(message) {
  const messagesContainer = document.getElementById('messages-container');
  const currentUser = getStore('currentUser');

  if (!messagesContainer || !currentUser) return;

  // Remove "no messages" placeholder if it exists
  const placeholder = messagesContainer.querySelector('p.text-gray-500');
  if (placeholder) {
    placeholder.remove();
  }

  const isOwnMessage = message.senderId === currentUser.uid;

  // Format timestamp
  let timeAgo = 'Just now';
  if (message.createdAt && message.createdAt.toDate) {
    const date = message.createdAt.toDate();
    timeAgo = formatTimeAgo(date);
  }

  // Get profile picture with proper fallback
  const profilePic = message.senderProfilePic ||
                    'https://placehold.co/48x48/e0e7ff/6366f1?text=' +
                    encodeURIComponent(message.senderName?.charAt(0) || '?');

  // Create message bubble
  const messageDiv = document.createElement('div');
  messageDiv.className = `flex items-start space-x-3 mb-4 ${isOwnMessage ? 'flex-row-reverse space-x-reverse' : ''}`;

  messageDiv.innerHTML = `
    <div class="flex-shrink-0">
      <img src="${profilePic}"
           alt="${message.senderName}"
           class="h-10 w-10 rounded-full object-cover">
    </div>

    <div class="max-w-xl ${isOwnMessage ? 'bg-indigo-100' : 'bg-gray-100'} rounded-lg p-4 shadow-sm">
      <div class="flex items-center mb-2">
        <span class="font-semibold text-sm ${isOwnMessage ? 'text-indigo-900' : 'text-gray-900'}">${message.senderName}</span>
        <span class="text-xs text-gray-500 ml-2 capitalize">${message.senderRole || ''}</span>
      </div>
      <p class="text-gray-800 whitespace-pre-wrap">${message.text}</p>
      <p class="text-xs text-gray-500 mt-2">${timeAgo}</p>
    </div>
  `;

  // Append message
  messagesContainer.appendChild(messageDiv);

  // Smooth scroll to the new message
  setTimeout(() => {
    messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
  }, 50);
}

/**
 * Markeer conversatie als gelezen voor de huidige gebruiker
 */
async function markConversationAsRead(conversationId) {
  try {
    const currentUser = getStore('currentUser');
    
    if (!currentUser) return;
    
    const conversationRef = doc(db, 'conversations', conversationId);
    const conversationSnap = await getDoc(conversationRef);
    
    if (!conversationSnap.exists()) return;
    
    const conversationData = conversationSnap.data();
    const unreadBy = conversationData.unreadBy || [];
    
    // Als de gebruiker in de unreadBy lijst staat, verwijder hem
    if (unreadBy.includes(currentUser.uid)) {
      const newUnreadBy = unreadBy.filter(id => id !== currentUser.uid);
      
      await setDoc(conversationRef, {
        unreadBy: newUnreadBy
      }, { merge: true });
      
      console.log("Conversation marked as read");
      
      // Badge wordt automatisch geupdate door de real-time listener
    }
    
  } catch (error) {
    console.error("Error marking conversation as read:", error);
  }
}

/**
 * Verwerkt het versturen van een reply
 */
async function handleReply(e) {
  e.preventDefault();
  
  const replyError = document.getElementById('reply-error');
  const replySuccess = document.getElementById('reply-success');
  const submitBtn = e.submitter || e.target.querySelector('button[type="submit"]');
  const replyForm = document.getElementById('reply-form');
  
  // Reset messages
  replyError.style.display = 'none';
  replySuccess.style.display = 'none';
  
  // Disable button
  submitBtn.disabled = true;
  submitBtn.innerHTML = '<i data-lucide="loader" class="h-4 w-4 mr-2 animate-spin"></i>Sending...';
  
  try {
    const currentUser = getStore('currentUser');
    const currentUserData = getStore('currentUserData');
    
    if (!currentUser || !currentUserData) {
      throw new Error('User not logged in');
    }
    
    const conversationId = replyForm.dataset.conversationId;
    
    if (!conversationId) {
      throw new Error('Conversation ID not found');
    }
    
    const messageText = document.getElementById('reply-text').value.trim();
    
    if (!messageText) {
      throw new Error('Please enter a message');
    }
    
    // Voeg bericht toe
    await addMessage(conversationId, currentUser.uid, currentUserData, messageText);
    
    // Toon success
    replySuccess.textContent = 'Reply sent!';
    replySuccess.style.display = 'block';
    
    // Reset form
    document.getElementById('reply-text').value = '';
    
    // Herlaad berichten
    await loadMessages(conversationId);
    
    // Verberg success na 3 seconden
    setTimeout(() => {
      replySuccess.style.display = 'none';
    }, 3000);
    
  } catch (error) {
    console.error("Error sending reply:", error);
    replyError.textContent = error.message || 'Failed to send reply. Please try again.';
    replyError.style.display = 'block';
  } finally {
    // Re-enable button
    submitBtn.disabled = false;
    submitBtn.innerHTML = '<i data-lucide="send" class="h-4 w-4 mr-2"></i>Send Reply';
    if (window.lucide) {
      window.lucide.createIcons();
    }
  }
}

/**
 * Gaat terug naar de messages lijst
 */
function backToMessages() {
  document.getElementById('conversation-detail-view').style.display = 'none';
  document.getElementById('messages-view').style.display = 'block';
  
  // Herlaad conversaties om up-to-date te zijn
  loadConversations();
  
  // Scroll naar boven
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// ========== END FASE 3 ==========

// ========== FASE 2.5: REAL-TIME BADGE LISTENER ==========

/**
 * Setup real-time listener voor unread badge
 * Deze functie moet worden aangeroepen na login
 */
export function setupBadgeListener() {
  const currentUser = getStore('currentUser');
  
  if (!currentUser) {
    console.log("No user logged in, skipping badge listener setup");
    return;
  }
  
  console.log("Setting up real-time badge listener for:", currentUser.uid);
  
  // Query conversaties waar de user een participant is
  const conversationsRef = collection(db, 'conversations');
  const q = query(
    conversationsRef,
    where('participants', 'array-contains', currentUser.uid)
  );
  
  // Setup real-time listener
  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const conversations = [];
    querySnapshot.forEach((doc) => {
      conversations.push({ id: doc.id, ...doc.data() });
    });
    
    // Update badge met unread count
    updateUnreadBadge(conversations, currentUser.uid);
    
    console.log(`Badge updated: ${conversations.filter(c => c.unreadBy && c.unreadBy.includes(currentUser.uid)).length} unread`);
  }, (error) => {
    console.error("Error in badge listener:", error);
  });
  
  // Sla unsubscribe functie op zodat we kunnen cleanup bij logout
  window.badgeListenerUnsubscribe = unsubscribe;
  
  return unsubscribe;
}

/**
 * Stop de badge listener (bij logout)
 */
/**
 * Scroll to bottom of messages
 */
function scrollToBottom() {
  const messagesContainer = document.getElementById('messages-container');
  if (messagesContainer) {
    setTimeout(() => {
      messagesContainer.scrollTo({
        top: messagesContainer.scrollHeight,
        behavior: 'smooth'
      });
    }, 100);
  }
}

/**
 * Handle inline message form submit (for replying in existing conversations)
 */
async function handleInlineMessageSubmit(e) {
  e.preventDefault();
  
  const messageInput = document.getElementById('message-input');
  const messageText = messageInput.value.trim();
  
  if (!messageText) return;
  
  const chatContainer = document.getElementById('chat-container');
  const conversationId = chatContainer.dataset.conversationId;
  
  if (!conversationId) {
    console.error("No conversation ID found");
    return;
  }
  
  try {
    const currentUser = getStore('currentUser');
    const currentUserData = getStore('currentUserData');
    
    if (!currentUser || !currentUserData) {
      throw new Error('User not logged in');
    }
    
    // Send message
    await addMessage(conversationId, currentUser.uid, currentUserData, messageText);
    
    // Clear input
    messageInput.value = '';
    
    // Reload messages
    await loadMessages(conversationId);
    
    // Scroll to bottom
    scrollToBottom();
    
  } catch (error) {
    console.error("Error sending message:", error);
    alert("Failed to send message. Please try again.");
  }
}
export function stopBadgeListener() {
  if (window.badgeListenerUnsubscribe) {
    window.badgeListenerUnsubscribe();
    window.badgeListenerUnsubscribe = null;
    console.log("Badge listener stopped");
  }
}

// ========== END FASE 2.5 ==========

/**
 * Initialiseert de messaging event listeners
 */
export function setupMessaging() {
  // Close modal buttons
  const closeBtn = document.getElementById('close-message-modal');
  const cancelBtn = document.getElementById('cancel-message-btn');
  
  if (closeBtn) {
    closeBtn.addEventListener('click', closeMessageModal);
  }
  
  if (cancelBtn) {
    cancelBtn.addEventListener('click', closeMessageModal);
  }
  
  // Form submit
  const messageForm = document.getElementById('send-message-form');
  if (messageForm) {
    messageForm.addEventListener('submit', handleSendMessage);
  }

  // ‚úÖ FIX: Inline message form (for replies in chat) is now handled by global event delegation in ui.js
  // No longer adding listener here to avoid conflicts

// FASE 3: Reply form
const replyForm = document.getElementById('reply-form');
if (replyForm) {
  replyForm.addEventListener('submit', handleReply);
}
  
  // Close modal when clicking outside
  const modal = document.getElementById('message-modal');
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeMessageModal();
      }
    });
  }
  
  console.log("Messaging listeners ingesteld (Fase 1, 2, 3 & 2.5).");
}
/**
 * Bekijk het profiel van een gebruiker (programmer of artist)
 */
async function viewUserProfile(userId, role) {
  console.log("Viewing profile:", userId, role);
  
  try {
    if (role === 'programmer') {
      // Fetch programmer data
      const programmerRef = doc(db, 'programmers', userId);
      const programmerSnap = await getDoc(programmerRef);
      
      if (!programmerSnap.exists()) {
        alert('Programmer profile not found.');
        return;
      }
      
      const programmer = { id: programmerSnap.id, ...programmerSnap.data() };
      
      // Display programmer profile modal
      showProgrammerProfileModal(programmer);
      
    } else if (role === 'artist') {
      // For artists, we can reuse the existing artist detail view
      // Navigate to artist detail view (if in programmer dashboard)
      const currentUserData = getStore('currentUserData');
      
      if (currentUserData && currentUserData.role === 'programmer') {
        // We're a programmer viewing an artist - use existing detail view
        // Import showArtistDetail from programmer-dashboard.js or call it directly
        // For now, show a simple modal
        const artistRef = doc(db, 'artists', userId);
        const artistSnap = await getDoc(artistRef);
        
        if (!artistSnap.exists()) {
          alert('Artist profile not found.');
          return;
        }
        
        const artist = { id: artistSnap.id, ...artistSnap.data() };
        alert(`Artist Profile:\n\nName: ${artist.stageName || artist.firstName + ' ' + artist.lastName}\nLocation: ${artist.location}\nGenres: ${artist.genres?.join(', ')}\n\nClick on the artist in the search to see full profile.`);
      }
    }
    
  } catch (error) {
    console.error("Error viewing profile:", error);
    alert('Could not load profile: ' + error.message);
  }
}

/**
 * Toon programmer profiel in een modal
 */
function showProgrammerProfileModal(programmer) {
  // Create modal element
  const modal = document.createElement('div');
  modal.id = 'programmer-profile-modal';
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
  
  const profilePic = programmer.profilePicUrl || 
                     'https://placehold.co/200x200/e0e7ff/6366f1?text=' + 
                     encodeURIComponent((programmer.firstName || 'P').charAt(0));
  
  modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
      <div class="p-6">
        <!-- Header -->
        <div class="flex items-start justify-between mb-6">
          <h2 class="text-2xl font-bold text-gray-900">Programmer Profile</h2>
          <button id="close-programmer-modal" class="text-gray-400 hover:text-gray-600">
            <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </button>
        </div>
        
        <!-- Profile Content -->
        <div class="space-y-6">
          <!-- Profile Picture & Basic Info -->
          <div class="flex items-start space-x-6">
            <img src="${profilePic}" 
                 alt="${programmer.firstName}" 
                 class="h-32 w-32 rounded-full object-cover flex-shrink-0">
            <div class="flex-1">
              <h3 class="text-xl font-semibold text-gray-900 mb-1">
                ${programmer.firstName} ${programmer.lastName}
              </h3>
              <p class="text-indigo-600 font-medium mb-2">${programmer.organizationName || 'Organization'}</p>
              <div class="space-y-1 text-sm text-gray-600">
                <div class="flex items-center">
                  <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                  </svg>
                  ${programmer.email || 'No email'}
                </div>
                ${programmer.phone ? `
                  <div class="flex items-center">
                    <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"/>
                    </svg>
                    ${programmer.phone}
                  </div>
                ` : ''}
                ${programmer.website ? `
                  <div class="flex items-center">
                    <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"/>
                    </svg>
                    <a href="${programmer.website}" target="_blank" class="text-indigo-600 hover:text-indigo-800">
                      ${programmer.website}
                    </a>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
          
          <!-- About Organization -->
          ${programmer.organizationAbout ? `
            <div>
              <h4 class="text-lg font-semibold text-gray-900 mb-2">About the Organization</h4>
              <p class="text-gray-700 whitespace-pre-wrap">${programmer.organizationAbout}</p>
            </div>
          ` : ''}
          
          <!-- Status Badge -->
          <div class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium ${
            programmer.status === 'pro' ? 'bg-green-100 text-green-800' : 
            programmer.status === 'trial' ? 'bg-yellow-100 text-yellow-800' : 
            'bg-gray-100 text-gray-800'
          }">
            ${programmer.status === 'pro' ? '‚úì Pro Member' : 
              programmer.status === 'trial' ? 'Trial Member' : 
              'Pending Approval'}
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Add to page
  document.body.appendChild(modal);

  // FIX 2: DOM race condition guard - check element exists before adding listener
  const closeBtn = document.getElementById('close-programmer-modal');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      modal.remove();
    });
  } else {
    console.warn('[MESSAGING] close-programmer-modal element not found in modal');
  }
  
  // Click outside to close
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.remove();
    }
  });
}
/**
 * Send recommendation notification to artist
 * @param {string} artistId - Artist user ID
 * @param {string} artistEmail - Artist email
 * @param {string} artistName - Artist name
 * @param {string} programmerId - Programmer user ID
 * @param {object} programmerData - Programmer data
 * @param {string} recommendationText - The recommendation text
 */
export async function sendRecommendationNotification(artistId, artistEmail, artistName, programmerId, programmerData, recommendationText) {
  try {
    // Check if conversation exists
    const existingConversation = await findExistingConversation(programmerId, artistId);
    
    let conversationId;
    
    if (existingConversation) {
      conversationId = existingConversation.id;
    } else {
      // Create new conversation
      const conversationData = {
        participants: [programmerId, artistId],
        participantNames: {
          [programmerId]: `${programmerData.firstName} ${programmerData.lastName}`,
          [artistId]: artistName
        },
        participantRoles: {
          [programmerId]: 'programmer',
          [artistId]: 'artist'
        },
        participantEmails: {
          [programmerId]: programmerData.email,
          [artistId]: artistEmail
        },
        participantProfilePics: {
          [programmerId]: programmerData.profilePicUrl || '',
          [artistId]: ''
        },
        subject: 'üåü New Recommendation',
        lastMessage: '',
        lastMessageAt: serverTimestamp(),
        unreadBy: [artistId],
        createdAt: serverTimestamp()
      };
      
      const convRef = await addDoc(collection(db, 'conversations'), conversationData);
      conversationId = convRef.id;
    }
    
    // Send notification message
    const notificationText = `I've written a recommendation for you! Here's what I said:\n\n"${recommendationText}"\n\nYou can view all your recommendations in your artist dashboard.`;
    
    await addMessage(conversationId, programmerId, programmerData, notificationText);
    
    console.log("Recommendation notification sent successfully");
    
  } catch (error) {
    console.error("Error sending recommendation notification:", error);
    throw error;
  }
}